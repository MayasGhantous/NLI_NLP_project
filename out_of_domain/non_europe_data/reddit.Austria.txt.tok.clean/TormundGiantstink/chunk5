  most devs can get away with only caring about the presentation layer , with their apps being consumers of some service ( often web services ), 
  the problem is that there 's no real default way to structure apps in android . 
  i 'm a big fan of bob martin 's [ clean architecture ] ( https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html ) , but i have n't really had an opportunity to implement something proper with it ( playground apps are nice and all , but not good representations of production apps ), 
  lifecycles . 
  having done nothing but desktop and a tiny bit of web development , that shit went right over my mind, 
  i understand it somewhat now , but do n't ask me about the fragment lifecycle , please, 
  i guess , telling them to sit somewhere else is not an option ? 
  i 'd make 2 modules : one , where your business logic resides ( your presenters and interactors ) and one that contains the platform specific stuff ( activities , fragments , databases ), 
  just stop using a massively outdated system that is hugely subjective and have your players come up with morals , motives and goals, 
  a question concerning websockets and rest services :, 
  when implementing a chat-service , it 's obviously better to use some sort of socket to retrieve chat messages from the other chatpartner . 
  what i 'm wondering is whether or not it makes a difference on battery usage when sending messages over the socket as opposed to making a rest call, 
  yeah , that 's how advertising works, 
  when i started out back in july last year , i found udacity to be horrible . 
  that may have changed , but it was horribly outdated back then, 
  that aswell as nobody liking kotlin circlejerkers, 
  counterintuitive , i know , especially on a sub about app development , but why not do it oldschool and have them write down the mileage before and after using the car, 
  or have them bring a receipt from the gas station and pay them that, 
  so it 's better to install some form of surveillance , gotcha !, 
  i want to seperate my business and presentation logic into different modules . 
  i used `` java library '' in the `` create new module '' dialog , called it `` core '' and added the dagger dependencies to my core : build.gradle, 
  now i get the following error message :, 
  `` ` gradle dsl method not found : ` annotationprocessor ( ) ' `` `, 
  gradle version is 2.3.1 , so that should n't be the issue . 
  here 's my module-level gradle file :, 
  apply plugin : ` java ', 
  dependencies {, 
  compile filetree ( dir : ` libs ' , include : [ ' * . jar ' ] ), 
  annotationprocessor ` com.google.dagger : dagger-compiler :2.9 ', 
  ( autogenerated by android studio ), 
  top level gradle :, 
  / / top-level build file where you can add configuration options common to all sub-projects/modules . 
  repositories {, 
  jcenter ( ), 
  dependencies {, 
  classpath ` com.android.tools.build : gradle :2.3.1 ', 
  / / note : do not place your application dependencies here ; they belong, 
  / / in the individual module build.gradle files, 
  allprojects {, 
  repositories {, 
  jcenter ( ), 
  task clean ( type : delete ) {, 
  delete rootproject.builddir, 
  for differing endpoints, 
  retrofit.builder builder = new retrofit.builder ( ) ;, 
  if ( buildconfig.debug ) {, 
  builder.baseurl ( testingendpoint ) ;, 
  else {, 
  builder.baseurl ( productionendpoint ) ;, 
  for stetho, 
  okhttpclient.builder builder = new okhttpclient.builder ( ) ;, 
  builder.networkinterceptors.add ( new stethointerceptor ( ) ) ;, 
  i believe that `` app terminated '' is not possible to detect correctly, 
  reminds me a bit of jessie j , i like it :d, 
  since all the other ones were taken already, 
  ctrl + alt + n to inline variables, 
  turns, 
  int i = 0 ;, 
  log.d ( tag , `` i : '' + i ) ;, 
  into, 
  log.d ( tag , `` i : '' + 0 ) ;, 
  that `` async tasks '' are n't real threading . 
  their only purpose is to move work away from the main thread . 
  they 're moved to a seperate thread and then executed in a serialized fashion, 
  someone get dinoflask, 
  in my experience , estimating how long a feature takes is largely tied to the application architecture . 
  a well defined architecture usually allows you to guess rather well , but if you do n't know the side effects of changes , then estimating becomes guessing, 
  swapping the onclicklistener is better, 
  maybe , you can even get away with a boolean that switches between two functionalities within a single onclicklistener, 
  we 're doing it like this :, 
  when using rxjava and retrofit , should i ` defer ` all my observables ? 
  so basically `` yes , you should defer them '' ? 
  retrofit uses okhttp as its networking . . thing, 
  you simply add a converterfactory for whichever json-deserializer youre using and get the parsed response object, 
  all of my responses look like this :, 
  `` status '' :200 ,, 
  / / whatever goes in here, 
  in retrofit , i could use ` setconverter ` to add a retrofit.converter to my restadapter-instance which would turn ` baseresponse < t  ` to ` t `, 
  how can i do that in retrofit2 ? 
  i know that there is the ` jsondeserializer ` interface that i could assign to my gson instance , but then i 'd have to register typeadapters for every single one of my responses , which is not feasible ( with over 60 different response-objects ), 
  potentially yes , that would mean that we would have to update every call to the new format , but it would be a possibility, 
  i mean , in my current iteration of rewriting the webservice i use ` map { it -  it.payload } ` which works kinda well , but now i have an additional command for every call , which annoys me, 
  afaik , there 's no real typical flow between writing ui first or logic first, 
  in mvp , you typically write your presenter first ( which controls the data flow between view and business logic ) , so you can subsequently write unittests, 
  think of presenters like controllers from mvc , but with the logic moved from the controller to their respective counterparts ( ui logic in ui , business logic in business classes ), 
  zeplin converts it to ` linespacingextra ` , so i always go with that, 
  has anyone some experience with mockito and kotlin ? 
  in my ( java ) unit test i 'm mocking the ( java ) retrofit interfaces using mockito , pass the interfaces into my kotlin class , but when calling the mocked methods , they return null instead of the objects i designated in my when-then, 
  i 've tried setting when-then both before and after passing the instance, 
  oh right , i should have mentioned that i wrote my tests in java, 
  ill edit my post, 
  you 're making your code depend on the android platform, 
  if you were to write code that would see use in both a mobile and desktop app , youd need to rewrite your presenters , because the desktop app ca n't use android specific mechanisms, 
  it 's called the `` joy of painting '' , not `` the joy of creating a perfect piece of art '', 
  it 's all about having fun , in the end, 
   i 'm mr. meeseeks , look at me !, 
  kaushik gopal 's talks made it click for me, 
  and, 
  then this article : https://gist.github.com/staltz/868e7e9bc2a7b8c1f754, 
  depends on the country .
