  chances are they could have been sun if they did not focus on the things they focused on . 
  it is very hard to stay relevant forever . 
  i would n't say that any of the giants of the 90s kept their relevance better than ms. maybe oracle is the only exception but sun is gone , ibm is not more relevant than ms. . . 
  i would n't call these players stupid . 
  why do you claim they have bad ai ? 
  certainly not true . 
  my friends who do n't know what reddit is and play in silver enjoy rushes far more than macro . 
  on the other hand they probably did not know about the voting either ... 
  unless blizzard decides to troll us and make it second to last , 
  what do you mean steppes of war was n't the most voted ? 
  i have to buy more accounts ... 
  i am with you brother . 
  / preparing molotov cocktails and removing the rust from that pitchfork . 
  cheese produces the most fun , creative and original games no matter if you do it or defend it . 
  hmmmm good point !, 
  on the other hand base races can just as easily be the end of cheese games rather than macro games ( think both players building cannons in each other 's base ) . 
  also it seems to me that when a base race starts it produces a cool game less often than cheese games . 
  bill gates is amazing . 
  if you are impressed by the movie maker e-mail you should check this article - http://www.joelonsoftware.com/items/2006/06/16.html, 
  the american government sucks . 
  must be microsoft 's fault !, 
  it is interesting not only because of the description of gates ' management style but also because it describes the process of evolution of major software . 
  i remember watching a video from a local openfest event where a representative of the local ms office had a presentation about ms and open source . 
  in the q&a part the audience trolled the ms representative by pointing out that ms deliberately introduced a bug with the dates in the ooxml formats . 
  sadly the ms representative did not know about the issue so the trolling was quite successful . 
  as i am watching the video i am like `` i can answer this . 
  it has nothing to do with politics , monopoly and promoting their software . 
  it is a deliberate decision to keep backward compatibility '' . 
  i was very impressed how in the software industry everyone along the chain can make the right decision and we still end up with inferior software and need to standardize bugs . 
  no mention of the size of the stack frame . 
  disappointed :(, 
  i always thought so . 
  i do n't know how this is not more obvious to programmers - people who should be good at working with information . 
  also people moving to management is a direct result of the fact that there is a shortage of experienced people to get the growing number of management positions . 
  if you have a bunch of developers and only one of them has a decade of experience you probably make him the boss . 
  interestingly both sides may be right . 
  maybe young programmers were much better for what facebook is ( or what it was at the time ) . 
  at the same time there are many projects that are not facebook . 
  i would be horrified if i see a financial institution develop software the way facebook does ( move fast and break things ? 
  it is ok to lose some data ? ), 
  so maybe projects with different requirements may benefit from different types of programmers . 
  so cobol programmers are staring down a barrel of a gun ? 
  i was under the impression that they were staring to see the end of that line of zeros on their paychecks . 
  so how much do node programmers make in comparison ? 
  algorithms do not produce complexity . 
  they solve very real problems . 
  yeah , right ... except that in some use cases one of them works and the other completes in 3 years . 
  i guess you used some known algorithms that you had to learn . 
  basically someone solved the puzzle for you to be able to do your job . 
  i am not saying that one is not a good programmer if he ca n't invent algorithms but certainly he should be able to learn algorithms . 
  i believe those interview tests actually test your pool of known algorithms and if you can recognize them , modify them and apply them to the task at hand . 
  yes , chances are if you do not know the algorithm you wo n't invent it but if you know a lot of algorithms you are more likely to know the algorithm than someone who knows less algorithms . 
  i freely admit that i will not pass that interview but i am under the impression that this is a mathematical optimization problem . 
  sadly it seems like it is more likely to be solved in the form of a riddle . 
  so the guy is a full for not migrating to php . 
  seems like back end php engineer is the most profitable thing , 
  but when you formulate it as `` back end php engineer '' it gives $ 117k, 
  yeah i get it . 
  there have been a few articles lately that claimed cobol devs were in demand . 
  they may very well be who knows . 
  chances are the stats on this site are not good for fields with very few developers . 
  beware with this approach . 
  while it is not the same as the one mentioned in the article you depend on implementation details of the orderby method and if these details change you may end up with the defect described here - http://blogs.msdn.com/b/ericlippert/archive/2011/01/31/spot-the-defect-bad-comparisons-part-four.aspx, 
  sadly , less efficient and less correct than knuth shuffle . 
  i wonder why they do n't add randomize method in the bcl already . 
  people write the worse code just because they do n't feel like implementing knuth shuffle every time . 
   no one should call themselves `` professional '' if they know only one language, 
  i am perfectly sure that this is not `` professional '' means . 
  if you get enough income from writing code to live off of it you are a professional no matter how many languages you know or how good you are . 
  just out of curiosity how long do you expect the project to take . 
  also why do n't you offer to pay the project maintainers to add the features you need ? 
  yes , he effectively means `` senior developer '', 
  `` knowing '' a language is so undefined . 
  in my university i have studied c \\ c++ , lisp , prolog , asm , java and c # . 
  currently from this set i would only say i know c # and java and i wo n't claim i knew java out of university ( i learned it later ) . 
  if we exclude domain specific languages like html and sql for the purposes of this conversation i know just one more language - javascript . 
  by `` know '' i mean `` i do n't mind being asked about this language in an interview '' . 
  i have gone through a video course on python and haskell and i read a book about f # some time ago . 
  do i know these languages ? 
  hell , no !, 
  they are nowhere to be found on my cv because if i put them there it means i am prepared to answer questions about them and i am not . 
  so do you know java or you do n't ? 
  i mean do you claim to know java because you can be proficient in a matter of days ? 
  i wish you luck . 
  this is by far the most interesting project i have seen posted here i could potentially qualify for with my c # background . 
  i do not have experience with bitcoin development but i would be willing to invest my own time into the research . 
  sadly i have other projects on my hands right now but your post was really important to me because it demonstrated that ms tech can be relevant in the bitcoin world . 
  but then why is my definition of `` knowing '' bad if his effectively agrees with mine ? 
  i did n't fall for it since i have read on more than one place that the guy is insane so i decided it was just manifestation of his madness , 
  well said !, 
  is n't that middle ground like huge ? 
  as a wp user i want to know too . 
  as a c # dev with wp experience i am willing to help if someone is developing a wallet for wp . 
  sadly i do not have experience with the bitcoin protocol nor the time to do that myself and i am not prepared to take the responsibility for software that works with people 's money . 
  does n't this defeat the whole purpose of node ? 
  thanks but there is no java for windows phone . 
  enums in c # are what enums should be and what enums have been for ages . 
  i find the obsession with oop enums unhealthy . 
  i love this series . 
  are you happy with the choice ?
