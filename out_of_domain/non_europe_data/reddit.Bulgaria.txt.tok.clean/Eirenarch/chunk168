  you can get to masters with 1 strategy per race and that is true for any game . 
  on the ladder people do n't know you so one strategy works as well as 10 strategies since it is always unexpected . 
  yes . 
  ok i am a noob . 
  analyzers are tools built with roslyn that analyze source code and can report errors with the usage of specific libraries ( much like style checker tools ), 
  of course it is not because they made all maps huge . 
  now after they implement the 12 workers start you will be able to claim that it is literally never used even on small maps , 
  not even on steppes !, 
  reducing the number of possible strategies is always bad . 
  also i know people who only play to execute this kind of strategies . 
  they have been chased away from the game . 
  remember that next time you are about to complain about small player base and viewer numbers . 
  please do add more strategies ( without increasing the number of units in the game ) but there is simply no reason to remove these ones . 
  there is absolutely nothing good in 12 workers start . 
  the mineral change is ok but starcraft 1 style economy that has been discussed is better . 
  both are unrelated to the 12 workers start . 
  i did n't call it 6 pool . 
  the 2 minutes are perfect not only because they contain strategies but also because it provides time for social activity and planning a strategy on the ladder . 
  for casters they provide opportunity to discuss the map and the players . 
  well maybe it is good for bad casters who ca n't fill 2 minutes with something interesting . 
  blizzard i do n't want you to enable my account for heroes of the storm and then proceed to send me an e-mail with 5 beta keys for it which i promptly deleted . 
  i have unchecked the game in the beta options . 
  look at this other game i have checked - starcraft and send me a beta key for lotv . 
  why do you think archon mode is going to bring back anything ? 
  we already had this in sc1 and no one cared . 
  i did n't care back then i do n't see a reason to care now . 
  sc1 was exclusively custom games after the first year . 
  it did n't even have a `` find match '' button . 
  practically no one played the ladder mainly due to `` fast '' game speed but also issues with lag . 
  of course i played on fastest too but ladder was on `` fast '' my point is that we did n't play team melee back then because it is a stupid idea although it was equal to practically every other game type supported from user interface point of view . 
  we played 1 vs 1 and 2 vs 2 and did n't care about archon mode . 
  suddenly people are excited about it because ... 
  i do n't know why, 
  why do you do it ? 
  i do n't think it can ever help . 
  best case is you get a job where you need to work with these tools and you fail . 
   if you like our ideas . 
  we need to band together and pressure blizz to consider this . 
  where do i sign up ? 
  do we need to take mike morhaime hostage on same event ? 
  i am with you !, 
  interestingly in early sc1 some maps had minerals placed differently on different locations . 
  before the `` balance everything '' mania this resulted in interesting non-symmetric builds . 
  players on the minerals deprived position would choose gas centric builds while players on the close minerals position would go for minerals centric builds . 
  now i do not advocate artificial imbalances but it would be interesting to see some maps with closer minerals and some maps with less efficient minerals . 
  the problem with silver is that swift is currently inferior to c # while being relatively similar and we already have a production quality mature framework to write apps for ios and android in c #, 
  c # is not proprietary these days . 
  it has been standardized for a decade and the compiler and the clr are open source . 
  one more barrier to multi-platform adoption of swift is that it is not suitable for purposes different from mobile . 
  its memory management is inferior in a server environment . 
  true but they are about to release v5 shortly and this still has significant amount of useful features that swift lacks ( most importantly linq and async/await ) . 
  also i do n't see the practical issue with the official standard being behind . 
  certainly was n't a problem for mono all these years . 
  linq + async/await beats these . 
  in fact i agree that swift has great potential and this is why i used `` currently '' . 
  i do n't think `` proprietary '' means what you think it means . 
  on a side note - design by committee is absolutely the worst . 
  i do n't mind someone liking the features i was just explaining why this effort is currently irrelevant . 
  it does n't matter if someone likes a feature it matters if the masses like it . 
  currently c # has more features known to the masses and liked by the masses than swift . 
  if you are going to develop in non-native to the platform language you 'd better capture the masses . 
  i also think the differences between swift and c # are small enough to make this point the biggest issue in this particular competition . 
  if it was an argument between c # and scala it would be quite different since the languages differ significantly . 
  in addition everyone is free to add something to c # or make a committee to manage a fork of c # with the desired features as long as they have their own name . 
  even more one can draft a proposal for the c # language and suggest it for inclusion in future c # versions . 
  while the decision to include it or not will not be democratic , a good proposal will probably make it in . 
  i am perfectly sure i trust the expert who are in charge for the language more than i trust the community to vote for or against a feature . 
  as for the design by committee java is one of the examples of the sad things that happen when a language is designed by committee . 
  interestingly i checked and it turns out that at least some of the things you quote were developed at sun before the jcp . 
  i specifically checked jdbc and servlets . 
  committees are only needed when there are political struggles in the community or when there is no entity in the community with enough reputation to lead the development . 
  it is not good for the tech but it is the best in a bad situation . 
  c did n't change significantly under the committee and c++ is not exactly my ideal of a language and i blame the committee . 
  i must admit i do not have any insight on the committee work on the other projects you mention . 
  if someone likes java the language more than c # the language he is plain wrong on practically every level and this has been discussed before many times ( bullshit generics , checked exceptions , primitive + wrapper types , etc. ), 
  the java platform may be stronger but considering the companies participating and the investment they pour into it i would say that the committee must suck if microsoft - a single company has managed to produce a platform only slightly behind what the combined forces of oracle , ibm , google and many more are able to produce . 
  seems to me like that committee thing reduces the efficiency significantly . 
  as for open source and c # i do not see how you are free to add to the original any more than in c # . 
  the only difference is that with c # you get your pull request accepted by the c # team and with committee you get your pull request accepted by the votes of the committee . 
  i do n't see the big difference . 
  have you missed the fact that c # is open source and the compiler is on github ? 
  let me know when your first mod to c++ goes in  ( i think given equal skill one has much higher chances to get something into c # than c++ ), 
  oh that 's certainly true . 
  when nobody cared about c++ it was probably easy to add something but few people wanted to . 
  i understand why there is an incentive to improve the project i just do n't understand where is the incentive to contribute it back . 
  having the bug fixed in your private fork will give you a competitive advantage over other companies using the same product . 
  only illegal in gpl is n't it ? 
  i do n't see how it would be immoral if the original author was ok with it as indicated by the non-gpl license . 
  the article tries to make the case that contributing to open source project is good for the business . 
  i am pointing out how this logic fails and i am being downvoted because what i suggested is supposedly immoral . 
  immoral or not i do n't see how this makes it incorrect . 
  yeah ... by building rust instead , 
   the compiler ( and roslyn uses the c++ compiler ), 
  just a small correction - roslyn is the c # compiler and it is separate from the jit . 
  also i think only . net native uses the c++ compiler backend . 
  ryujit does not . 
  i may be wrong though . 
  it would be cool if someone can confirm that . 
  i guess it depends on the scale and your ability to maintain the project . 
  so if you are oracle you will probably profit from not contributing because you have the resources to merge from the original project .
