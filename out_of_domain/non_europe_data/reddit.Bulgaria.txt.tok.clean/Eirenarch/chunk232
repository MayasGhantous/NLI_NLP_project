  i ca n't imagine either so i compare to my development experience which is slower when i have to check in comparison to just creating db by hand and them mapping entities on top of it . 
  seems like the sc game engine team is quite competent while the battle.net team is full of shit . 
  the former fixed two bugs reported 3 days ago and the latter can not remove the `` leave league '' button for 3 months now ( let alone fix their actual bug ), 
  you mean to pioneer technologies like css , xmlhttprequest and multiprocess browsers ? 
  i ca n't easily find info on how it deals with the lack of expression trees in java . 
  does it change the bytecode or something ? 
  because java is so limited people need `` advanced bytecode analysis algorithms '' :(, 
  i was quite bored by the story of otherwise great website . 
  i hope they add something with cache, 
  he is correct in the sense that you ca n't have alternative implementation of expression trees however i have a hard time thinking of a reason to want alternative implementation of expression trees . 
  that would be like an alternative implementation of the delegate class, 
  is n't 4 years of xamarin experience a bit of extreme requirement . 
  you are looking specifically for first adopters ? 
  yes . 
  if only you can use scala and your boss or coworkers do not block you . 
  . net is correct java is wrong  also expression trees are in fact an interface . 
  strange . 
  i always assumed it was in the standard . 
  it is not really the frameworks and choices that is annoying . 
  i can deal with that . 
  it is the fact that there is no standard way to do things . 
  you have to piece the toolchain together . 
  now maybe it is my . net experience and people who work with say c++ will be used to this but i am used to running the ide and it has compiler , web server , unit testing , debugger , package manager , etc. 
  out of the box . 
  i do n't need to install ruby to compile sass or something . 
  and then because there is no standard way things sometimes do n't play well with each other and some random gulp task breaks somewhere with some console message that maybe you did not even notice while trying to pointlessly refresh the page but the js files were not updated . 
  then when you see the error you go back up your toolchain to find the actual task that broke the pipeline all through consoles and codified tasks in text files . 
  even worse is that you do n't want to drop any of these because if you do you actually degrade your dev experience and go back to es5 js bullshit , browser differences , unorganized jquery soup , repeating code in your css , etc. 
  yes but it is quite obvious that there are far more jobs and companies using java and c # than scala . 
  i also use the word `` normal '' instead of `` cisgender '', 
  i feel for you . 
  i already have a pretty good understanding of server side and core javascript so while the whole front end ecosystem did in fact drop on my head all at once at least i did n't have to learn the other aspects of the stack at the same time . 
  if i was faced with all this when i was starting i would probably quit and go sell computers or something . 
  and people say the web forms page lifecycle ( where i started back in the day ) is complex ... 
  oh man i wish this was true . 
  i am so bored of big maps . 
  also one of the very few that organize 2 vs 2 tournaments even if it happens very rarely . 
  if that was all they did they would still be a net positive for the scene . 
  a single front-end library is probably more complex than web forms but the full toolchain is more complex than any web forms application i have seen . 
  i actually like web forms . 
  i would change a bunch of things if i had to build it from scratch but the overall concept is pretty much ok . 
  components  barebones mvc ( as seen in asp.net mvc 5 ), 
  i like the title . 
  `` stuff you 'll have to learn to live without '' . 
  what if i choose to live without . net core instead ? 
  i can think of a lot of useful things that can be built without system.reflection.emit . 
  you may be right but i do n't think people use . net because it is fast to target vm . 
  i am pretty sure the main reason is the relatively high quality of the bunch of libraries and the bunch of weird languages compared to competing ecosystems . 
  because the title is the only new thing for me in this thread . 
  i had already read the full blogpost and watched the video two days ago . 
  yes this is what i am saying . 
  oh they are gon na get serious about the code of conduct ? 
  that 's what the community wants , is n't it ? 
  btw while we are talking about maps there is this 2 vs 2 where land routes are blocked by rocks and it starts as an air map for all races ... except terran . 
  reapers can make it to the enemy base . 
  i find this totally absurd . 
  every game is bound to evolve to `` by heart '' build orders . 
  the designers can make it less important by adding other elements that decide the game like micro but i do n't see how developing muscle memory is more fun than developing and learning build orders by heart . 
  on the other hand i do believe that team rts niche has been totally underserved ever since the sc community woke up one day and declared that 2vs2 can not ever be balanced and therefore there should n't be any tournaments . 
  however i am hoping for a more classic rts than the current state of atlas . 
  in my experience it does n't work like this . 
  build order wins do happen but they are relatively rare . 
  of course on the very high level when players are equal and look for the most minor advantage in order to win build orders can provide it but as soon as you drop down to top 5 % of players ( as opposed to top 1 % ) the better player can handle build order disadvantage just fine . 
  in addition there are build orders that are safe from build order losses usually depending on additional scouting and giving slight economic disadvantage . 
  while you are right in the sense that there is rps in bo * advantages * it is mitigated by other aspects of the game like mechanics ( both macro and micro ) , timing and decision making . 
  also in my experience in team-based sc bo wins are more rare since it is hard to rps both or ( in comparison to atlas ) three of your opponents . 
  at least one will hard counter you and chances are you get scouted because 3 people are looking around the map . 
  i am a bit of worried that atlas may go more of a dota route where it depends on extreme variety rather than well-designed units . 
  i highly dislike that . 
  i prefer games that have very few units and skills but their interactions are very interesting . 
  i prefer deep to wide when it comes to games . 
  take chess for example . 
  it is such a great game but it has a total of 6 units . 
  well i want to play on them because they are different from the other maps in the pool even if they favor one strategy ( a statement i disagree with ) . 
  the solution is of course simple - more maps in the pool and more vetos . 
  everyone plays on the maps he wants . 
  i would pay a dollar per ladder game to play on the wol launch maps . 
  i loved that time in the game so much and it was mostly because of the maps . 
  i 'm here . 
  when i become emperor of the world i am bringing back steppes of war i swear !, 
  i may even consider having gladiator fights on steppes where whoever loses dies . 
  btw i always felt like the reaper is an extremely stupid unit . 
  useful for scouting and rushes at the start of the game and never ever produced after the starting stages . 
  what kind of stupid unit is that ? 
  it has been redesigned like 5 times and is still extremely stupid unit . 
  i strongly disagree with / u/antares293 but the post contains reasonable arguments that may apply to every skill level . 
  he is in south korea which is different from north korea . 
  learn some geography man !, 
  pointless act since nobody can ever take these wins from him . 
  they are documented all over the internet and we were there watching him win . 
  the battlecruiser/marine rush !, 
  the parallel class is useful for cpu intensive operations . 
  there is no benefit in using it to make http requests . 
  it is a bad design . 
  a unit should be viable ( no matter the role ) at all stages of the game to enable more diverse strategies without placing the burden upon the player to learn about more unit . 
  make the game deep instead of wide . 
  your alternative is to use async requests that do not occupy threads and therefore do not burn cpu time and memory doing nothing . 
  you just fire off a bunch of tasks and do a task.waitall ( assuming you want to wait all ) so you do not create 64 threads on the poor thread pool . 
  first of all you do n't need the threads anyway ( they consume memory for a call stack not only scheduling time ) and second i do n't think work stealing means what you think it means . 
  the thread will not be returned to the pool simply because it is waiting .
