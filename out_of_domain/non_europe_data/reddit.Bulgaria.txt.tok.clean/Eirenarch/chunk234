  i dropped out when they cut masters to strict 2 % . 
  in the first year i was in fact in the 1-2 % range but there were more players then . 
  yeah if somehow i could exclude my terran games i would probably never drop out of masters . 
  i do cheese and i do abuse random though . 
  sometimes i even do defensive ( macro ) cheese where i abuse the fact that the opponent is unlikely to execute a certain rush ( say bunker rush ) because he does n't know my race and the rush sucks against another race so i ca n't claim that i 'd be masters with a chosen race ( though based on stats i do believe i could reach masters as zerg on my current level even if i do n't random ), 
  this is great and i am glad i will be able to use this in all those reddit and elsewhere technology flamewars . 
  too bad i never had a project where that level of performance was important and at the same time the projects i work on have a bunch of requirements that are still not supported properly in asp.net core . 
  i am not a little bit ashamed of cheesing especially since one thing i love more than cheesing is being the defender of a cheese and i also love watching cheese in pro matches . 
  i do play macro too with about the same success rate . 
  that advice is assuming people ( like me ) who need certain functionality find any value in core as opposed to 4.6 where the functionality is already present and there is significant know-how on how to use it . 
  the mono project also mimics the architecture of . net full and not the barebones architecture of . net core . 
  i work in a relatively small city and although there is a good choice of companies most of them are small . 
  i am not aware of any company that does whitebox testing ( most of them have qa teams but they are doing black box ), 
  i was not joking about writing tests being boring and debugging being fun . 
  of course the rest of it is a joke , i would write tests if the project demands it . 
  comparison with netty means that asp.net kicks node 's ass and pretty much everything non-java/go/c + + out there . 
  documentation is a major issue with asp.net core but it is kind of expected at this stage . 
  i do n't see core being a better option for new projects in the next two years unless the project is supposed to be in active development past the two years or the project needs extreme performance and throughput . 
  for most projects . net full will be a better option for some time . 
  why do you think it is hard to catch ? 
  it happens every time the property is used . 
  you literally need to never run any code using the property to not catch it . 
  i understand your pain and i have been there too but i do n't think this qualifies as hard to catch let alone `` extremely hard to catch '' . 
  i 'd probably agree that this should be an error ( obviously not an option anymore because of backward compatibility ) but i 'd qualify it as `` annoying '' rather than `` hard '' . 
  there is literally no way this ends up as a production bug unless you never tested your code involving the property and at this point you have a bigger issue . 
  not programming ? 
  say you want to increment a person 's age . 
  person.age + + ;, 
  person.setage ( person.getage ( ) + 1 ) ;, 
  the sheer amount of braces makes it less readable . 
  i agree with the idea of the article in general but there are sometimes clear cases for microservices that make debugging and development easier . 
  for example a subsystem that sends e-mails is quite ok in the form of a microservice . 
  you just send it messages and it sends e-mails . 
  it is easier to develop and debug in isolation and you get some deployment benefits . 
  i would assume that the correct signaling behavior is to wait for classic to fork via incompatible block and sell the coins on the core network . 
  i know you are not a fan of orms but could it be that you are hitting a bug equivalent to this one with your data access code http://stackoverflow.com/questions/28543293/entity-framework-async-operation-takes-ten-times-as-long-to-complete, 
  yes but according to the post if you do n't use ef you can set that command option to sequential and you wo n't have an issue . 
  with ef you do n't get that level of control . 
  yeah . 
  but if you are using asp.net today you do n't care about deploying on linux anyway . 
  maybe in 3 years it will be different but not today, 
  the joke is precisely that the pronunciation is forgotten . 
  i look precisely at this speed  they iterate fast but the overall output has not changed much . 
  you can use what is ready faster than before but after 3 years you have the same amount of new features as we did before . 
  of course it is better to use what is ready when it is ready but it comes with a price - bad docs and parts that are substandard that shipped because they were needed for what was ready . 
  i 'd be willing to go for it ( especially since the money does seem ok to me but i guess this is just easter european thing  ) but as / u/ostralyan pointed out it is not clear what kind of problems your users want help with . 
  also how do you schedule the `` meeting '' ? 
  people who use map hacks are crap and if they leave the game good riddance !, 
  i do drink and play too . 
  most often i drink when playing 3 vs 3 with a noob friend of mine and my noob girlfriend . 
  this way i do n't get angry , 
  just one more question . 
  do i need to be on the website to receive the request ? 
  if there is an e-mail notification what happens if i am not available at the required time ? 
  also your website breaks in microsoft edge . 
  yeah i know , not the most popular browser and i certainly have installed others but c # developers are likely to use it with higher than average probability , 
  as i see it this skill comes with time and you can not learn the useful versions without seing them in actual projects . 
  by all means go read about cqrs , service layers , repositories and all these but the only way to know why they work or when they wo n't is to see them in actual projects . 
  when you work at a company your feature usually mimics the architecture of other features in the project and you are not the one making that decision anyway so you just study the current architecture and apply it to whatever feature you are given . 
  the only real advice i can give you is whatever you read or use always try to understand what problem it claims to solve and how does it actually solve it . 
  if you ca n't answer these questions you either do not understand the pattern or the pattern is bullshit . 
  for example i do not understand cqrs but i am pretty sure the repository pattern over entity framework is just bullshit . 
  i know because i tried to answer the questions above . 
  the answers for cqrs was `` i do n't know '' and the answer for repositories was `` they do not do what they claim to do '', 
  what do you base this statement on ? 
  flow seemed like a really good idea when it was announced but i have not heard anything of the project since . 
  good to know . 
  i was expecting the flow tooling to catch up but obviously it is either far harder to implement with inferred typing or they just could n't catch up in such a short time . 
  or maybe both . 
  also note that these are often totally misused . 
  for example pylon + overcharge rush before patch was hardly cheese because it was a relatively even micro battle even when scouted and countered , let alone that the protoss can simply not build the pylons if he sees a heavy counter . 
  however people will cry cheese . 
  also there were times when casters declared that `` he is going for a second all-in after the first one failed '' ( sometimes even third ) which should not be possible since after failing an all-in the game is supposed to end with no meaningful action for the side that failed . 
  that 's stretching the definition and definitely not what it means in poker . 
  i think the days of windows lockdown are over . 
  these days the goal is to get developers to use azure , not to milk them via windows lockdown . 
  this may or may not happen but it is not of extreme importance since . 
  with time the upgrade becomes less and less relevant as new machines replace old ones and they come with windows 10 where upgrades will be free for as long as the hardware is supported by the new version of windows and those who do not upgrade in the first year are likely hell bent to not upgrade anyway . 
  that is one thing . 
  azure is a great option on many accounts . 
  there is a reason it is number two in an extremely competitive market . 
  i do n't see them porting it either because it is quite hard but i bet they are not gon na try to block that jetbrains ide or do anything else to prevent devs from leaving windows . 
  in fact i think that the current . net crowd does n't mind windows at all so basically they do n't have to do anything to keep that crowd . 
  people who dislike windows already left . 
  i do n't see how an api that is 100 % backward compatible with what they had in 8 and virtually nothing was deprecated counts as `` total overhaul '', 
  so did they do that ? 
  no more com underneath ? 
  so where is the `` total overhaul '' ? 
  i doubt that 's the devs though . 
  if they dislike it they can just leave and go work on non-windows . 
  we need pc bro on the team sending change requests for pieces of code with inconsiderate naming . 
  yes but i mentioned jetbrains in the context of non-windows platforms . 
  visual studio is not available there . 
  why is n't this the post but some nytimes retelling ? 
  sigh ... 
  original blogpost - https://blogs.windows.com/buildingapps/2016/02/25/an-update-on-the-developer-opportunity-and-windows-10/, 
  i am so glad they did n't keep this one . 
  the idea that microsoft 's ecosystem is app-starved is bullshit . 
  the real problem is it is user-starved . 
  it is not a chicken and egg problem .
