  in fact we were conquered by the ottoman empire ( we insist that we were being `` enslaved '' to convey the sentiment although it wo n't fit the definition of slavery ) so if anything we were more like being a colony . 
  let alone that i had not seen a black man ( excluding gypsies ) in person maybe till the age of 10 . 
  how can you convince me that i have been privileged if everyone around me was white and neither me nor my predecessors benefited from colonialism ? 
  same goes for religion . 
  for five centuries we were a religious minority in a caliphate ( a real one ) . 
  we also clearly remember communism . 
  sjws usually stand on the economic left . 
  i am not old enough to have studied karl marx in school but i did recite children 's poems about lenin . 
  we know this shit does n't work because we lived through it ( although there is a lot of nostalgia ), 
  and finally our women are tough . 
  if they were insulted by words they would n't be able to make it through high school . 
  most of us were at some point taken care for by our grandmothers and while the families were kind of patriarchal in general when it came to house work and raising children both my grandfathers were commanded by my grandmothers without objections . 
  it is hard to imagine that women can be oppressed in this environment by a mere boss or coworker . 
  that being said things are slowly changing and we 're adopting western attitude as our cultures merge . 
  there are more and more people who lean left ( young who do not remember and 50 + who are nostalgic and could not adapt in the transition to capitalism ) . 
  there were even emerging sjws but then the migrant crisis hit us and the backlash against them is very severe . 
  right now at work i can just go to my boss and tell him a racist joke and he will tell me one back . 
  i recognized that most of the article was reasonable i just chose to comment on this part . 
  i do n't do anything interesting with the data in most projects . 
  i imagine that if i did i would know all of these tricks . 
  would be a usability issue . 
  this example is human written and there will be machine generated code that looks like this . 
  better limit the feature in other ways than depth/time . 
  are we sure it is ? 
  some people suggest that stringliteralconvertible feature may be the issue . 
  a friend of mine is responsible for that . 
  he writes them e-mails and made them include assembly and then wrote more e-mails to fix their keywords , 
  he claims that every program should be written in assembly , wrote an asm ide and a web cms in asm - http://asm32.info/, 
  it could but it may not because they tested with 2 items in the dictionary . 
  then you run the tool and one day you ca n't compile the code because in your case it generated a lot more items . 
  unless you developed the tool or are able to fix it you are stuck . 
  i fully agree with you but it is not like the author suggested i read ayn rand in addition to karl marx . 
  sure but limiting the feature in the language itself is much more robust solution . 
  he 's totally crazy ( but not in the socially problematic way ) . 
  he does n't go around without pants and such . 
  on the other hand he is openly communist but not the bernie way . 
  he is hardcore . 
  he supports stalin and claims the people he killed deserved it but most of the victims were made up by slozhenicin and such . 
  you can add the types but then you have to add them after each generation . 
  this will work if you can modify the code of the generator but if you are using one out of the box it wo n't be fun maintaining its code in addition to yours . 
  if you have access to the code at all . 
  close enough but he is bulgarian . 
  and not that russian and bulgarian are close in general but in this particular case ... 
  yes . 
  when you are building a programming language it matters because the programming language interfaces with each and every tool for every user . 
  it is not like your javascript calendar library . 
  i doubt it . 
  i hate to imagine the fix to linq to sql generator for example . 
  or the ones for gui designers . 
  and they are not even open source . 
  haha i had to check who euronymous was and although i do know the band mayhem and the murder story i could not relate the name . 
  honestly facts do seem to line up . 
  if only we find evidence that euronymous practiced the ancient rituals of assembly it would be practically proven . 
  again it assumes that the code base is trivial and that the code is available . 
  so we must assume that the code generation tool is maintained and this bug should be fixed there but the swift compiler is free to not fix their bug because everyone can fix their tools to work around the bug instead ? 
  nice logic . 
  well then they failed at language design if such a simple use case could force the compiler to choke . 
  if you design a language that people have to work around just because each specific case is easy to fix you end up with javascript and php which are pretty much a list of exceptions that you should avoid . 
  better to simply remove the feature or limit it in another way . 
  a compiler bug/corner case is much more severe than anything else . 
  the bug is amplified through every piece of code out there . 
  they could have dropped the inference from dictionary literals for example and included the type of the dictionary in the literal itself . 
  still useful and no corner cases that compile in 12 hours . 
  i am trying to argue that a bug in a language/compiler is much more severe than a bug in a library , framework or whatever and is therefore not justified even if the feature is generally useful and the bug is in a corner case ( although i wo n't call this case `` corner '' ), 
  it is a dictionary literal . 
  i do n't have to have experience with swift to have experience with dictionary literals . 
  also we are commenting on an article where the user hit the bug and lost time investigating in a reasonable real-world use case . 
  corner case or not this is significantly worse than not being able to infer the type of a dictionary literal or even not having a dictionary literal at all . 
  so why the hell do they need the feature ? 
  just restrict type inference to not work on dictionary literals . 
  problem solved . 
  can confirm . 
  except zerg . 
  zerg is easy even as random . 
  i see nothing ironic ( except that the usd is n't backed by gold anymore ) . 
  she was n't against currency , she was against using people as currency . 
  frankly that may be irrelevant . 
  in the past year i have not seen or heard anyone starting a real world project with js that does not involve some kind of transpiler . 
  if you are going to transpile your js downlevel you can just use typescript and get additional benefits . 
  one can also argue that browsers do support typescript just not the typing part , 
  you have lost nothing . 
  everything es6 is valid typescript so ... 
  once ts2 ships it will be better even if you prefer dynamic due to flow typing . 
  as if better intellisense is a small thing . 
  it is even more useful while learning . 
  what 's that ? 
  there were people who doubted anders ( hallowed be his name ) ? 
  heretics !, 
  on a more serious note when did the strong script experiments `` fail '' ? 
  also note that typescript 2 will add flow based typing ( similar to facebook 's flow ) which means that even if you do not write a single type and go all dynamic typescript will still inform you about some errors . 
  the tooling with some type definitions will also be very useful to people who do not care about types so typescript will be ( or maybe is today ) the best way to write dynamically typed javascript . 
  the compiler analyzes the code statically and figures out the possible types for variables even if they are not explicitly declared . 
  https://channel9.msdn.com/events/build/2016/b881 - skip to ~ 45:00 ( 15 min total ), 
  because excluding web assembly the underlying language dictates parts of the semantics of the compiled language and also because you still need to debug . 
  source maps work but even with typescript many tools fail to provide accurate information . 
  they provide accurate line numbers but i have seen cases where a variable name means one thing in a typescript class/namespace and another in javascript . 
  the final reason is the ecosystem and know-how . 
  you can not only call into the js ecosystem with typescript you can fully embrace it like literally copy/paste stuff into your codebase . 
  well yeah . 
  if you see php there is no wonder you see javascript .
