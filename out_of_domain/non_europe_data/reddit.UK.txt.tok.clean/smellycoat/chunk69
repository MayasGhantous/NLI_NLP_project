  touch\u00e9 , sir . 
  erm , slightly off-topic , i know . 
  but is there a good reason his chest hair is [ shaped like australia ] ( http://i.imgur.com/rsxxw.jpg ) ? 
  i , for one , hope so !, 
  that 's a reasonable point . 
  what i was trying to say was , google 's business practices certainly do appear to err on the side of `` good '' , rather than `` evil '' . 
  they 've had plenty of opportunity to cash in on all the good will and favourable market position for a quick payday , but they seem to prefer to go in directions that benefit everyone , rather than just themselves . 
  that 's not to say they 're perfect , the privacy concerns alone are certainly worrying . 
  i know this is kinda fluffy and general , and they could still have an evil master plan up their sleeves . 
  but ms ( and apple ) have already proven that they 're willing to fuck over their users to make a profit , something that google are yet to do . 
  ooh , thanks . 
  i 'd been putting off designing a favicon for the app i 've been working on . 
  turned out to be surprisingly well for 3 minutes work !, 
  hey man , i 'm glad your gran had someone there for her , and i certainly do n't mean to disparage anyone 's efforts . 
  maybe i should have worded that as `` the best they can offer that others can not ... '' . 
  my only point is that christians do n't have a monopoly on charity , 
  we played it in team mode , with the no-radar cheat , an aerial splitter , an extra tv and two sheets of tin foil ( sticks to the crt due to static , and is opaque ) . 
  goldeneye is serious business . 
  yes really !, 
  it sticks !, 
  omniture 's billing model is essentially `` now you give us all your money '' . 
  it 's got a lot of features , though . 
  yeah , i do n't care whether they 're on the left or the right ( i use windows and os x as well ) , but not having the close button in the corner seems like being different just for the sake of being different . 
  yeah , those bastards , making your printed output look less cheap . 
  fonts are really important . 
  each has its own personality and character that it imparts on the overall design of the final product . 
  while the untrained eye may not be able to quantify the differences , the differences are still important . 
  consider this : you can tell the difference between between a nicely-designed physical product , and a poorly designed one , right ? 
  you can `` feel '' the difference , even if you ca n't quantify it . 
  the differences may be subtle , choices of material , the way it 's balanced , the weight distribution , etc. 
  two things could do exactly the same job , but one is clearly better . 
  the difference , to the layman , is `` design '' . 
  the same thing goes for documents . 
  subtle differences ( fonts being an important one ) can be the difference between something that appears cheap and something that appears professional . 
  simple changes ( like switching from arial to helvetica - which are hard for the layman to tell apart ) can make a big difference to the overall feeling of quality . 
  i 'm no designer ( i suck at it ) , but design has always been something i 've had an interest in - for this very reason . 
  now , to be entirely honest , your company should not be offloading the complexities of implementing their chosen designs on their general workforce ( who are just trying to get shit done , and rightly do n't give a fuck how it actually looks ) . 
  so if they 're making you jump through hoops for it , then they 're doing it wrong and you 're justified in moaning about it . 
  but it * is * still important ( even if the differences seem extremely subtle to you ) . 
  that 's why designers exist . 
  some stretched or squished in horrible ways , but it 's still helvetica . 
  i know fuck all about skate shoes or skating in general , but i buy the shoes as normal trainers just look ridiculously long and thin at larger sizes . 
  [ kate 's skates ] ( http://www.kateskates.co.uk/ ) is usually where i get them ( they have a search-by-size option ) . 
  if you want a comfy pair at 13 + sizes , i recommend etnies ( i 'm usually 14 , but their 13 is big enough for me ) . 
  fuck knows how useful they 'd be for skating , though , 
  if gabe newell reads reddit , we ai n't never seeing ep3 . 
  the behaviour may not be guaranteed legally , but handling of nxdomain results are certainly defined in the relevant rfcs ( 1034 and 1035 , iirc ) . 
  so what they 're providing is a non-rfc compliant dns server that circumvents the automatic searching capabilities in browsers to make a little bit of cash . 
  dell are okay if you want a cheap low-end system . 
  they have a lot of pull with their suppliers and can get older mid-range hardware very cheaply , meaning their low-end models are a little outdated but very cheap ( but lacking much scope to upgrade ) . 
  if you want a cheap box , then they 're a good choice , but start to become less competitive when you look at optional upgrades , which are often overpriced . 
  at the higher end , they trade on their name . 
  so they 're basically selling to either companies who already buy from dell , or people that are looking for a prebuilt system from a known brand . 
  price competition is less important in the higher-end market as different components make it hard to make direct comparisons . 
  you also have to be careful with the `` cheap '' higher-end systems , as they will focus on keeping the price low by skimping on stuff like graphics cards ( which have complicated model numbers that are hard for the layman to understand what they 're actually getting ) . 
  if you have the patience to research and build your system from components , you 're likely to end up with something that 's of generally better quality , and ( importantly ) exactly specced to your needs without having to pay their rather inflated upgrade prices . 
  bear in mind that when you spec a custom system , you 're likely going to be starting with a power supply and motherboard that 's far better than the cheap , generic things that dell use ( ie vaguely capable of overclocking , and not manufactured by the lowest bidder ) . 
  i got bitched at for using one of those `` spinner '' animation things to indicate something 's happening ( it was a web app , so said `` something '' was going to be around a second in most cases , maybe up to 10 seconds at most if the user was on a shitty connection and our servers were under abnormally heavy load ) . 
  progress bars give the user some idea of how long they 're going to have to wait , granted , but in many cases that just is n't possible . 
  buuuut i was told to write one anyway . 
  so i ended up with a progress bar that takes just gets slower as it progresses . 
  i tuned everything so it took about a second to get to 50 % ( and then a second to get to 75 % , another second to get to 87.5 % , etc ) , but it would never actually completely finish . 
  after a response came back it filled the remainder of the progress bar in around a second before moving on . 
  despite the fact that this now meant that responses took on average 2s instead of 1s , it was immediately heralded as a success . 
  i do in situations where it 's not entirely obvious how to address somebody , or you know you 'll have a slightly awkward `` no no call me < firstname  '' thing . 
  so i just avoid them altogether . 
  my girlfriend and i have been together for over ten years , and i have never once referred to either of her parents by name . 
  i have to admit it often feels that way . 
  no , in some cases measuring productivity * is * worse than not bothering at all . 
  whenever you use a naive or incomplete measurement of productivity , you end up with people `` gaming '' the system . 
  if you 're using loc to measure productivity , then you 're indirectly encouraging developers to write more code , regardless of what they 're actually doing . 
  in that situation it does n't take long before people start doing silly things like replicating entire classes rather than fixing and testing a small bug in an existing class - because it means more loc . 
  if you must measure productivity , you need a * complete * measurement , or you 're only making things worse . 
  problem with giving developers bonuses is that management usually do n't completely understand the nuances of a developer 's job . 
  in theory , it 's a good idea . 
  but in practice , because it 's actually rather hard to formally measure productivity , it changes the way developers work to fit whatever measurements you * do * have in place . 
  if you measure loc , then you end up with the same job being done in lots more code ( eg , the answer to the question `` should i patch this class to do what i want , or make a completely new class ? '', 
  changes from `` whatever is most sensible/flexible/best for the codebase '' to `` whatever will result in more code '' ) . 
  so while it 's definitely possible to give developers bonuses , it 's tricky to do it without changing the way they work . 
  the method we 've used in the past is to give the entire team goals , and reward all the members if they reach them . 
  that 's slightly better ( as everyone 's working for the same thing ) , but still affects the way the team works ( eg , finishing new features becomes more important than fixing old bugs ) . 
  it 's really tricky to do right . 
  actually , in the common case , the bar proceeded at an approximately linear rate . 
  on average , the request took around a second ( at which point the bar was at 50 % ) , and then took about a second ( just under , iirc ) to complete . 
  it actually slows down slightly between 0 and 50 % , but it 's not really noticeable . 
  as i 've said , metrics for the purposes of performance assessment * will * change the way people work . 
  metrics that do n't take into account all the possible things that could be considered `` good work '' ( and there are a lot ) inevitably lead to ( possibly perceived ) unfairness in performance assessment , which itself leads to a temptation to `` game '' the system . 
  counting loc will tempt developers to pick the longer-winded solution when they get the chance . 
  using commit counts will tempt them to make many smaller commits rather than grouping changes into commits that make most sense . 
  counting `` features implemented '' will temp them to pick easy-to-implement features and neglect bugs , counting `` bugs fixed '' will tempt them to pick easy bugs and neglect new features ( or worse , fix bugs or implement features in the quickest , hackiest manner they can ) . 
  now you may argue that `` good developers wo n't do that '' , or `` but it works in the majority of cases '' . 
  but it creates another problem : imperfect measurement leads to some degree of unfairness in performance assessment - you 're not measuring everything so there will always be some situations where you get it wrong . 
  as soon as someone gets screwed over by a system they perceive as unfair , their choices are to either ignore it and continue regardless ( tricky if their remuneration is tied to it , which is what we were originally discussing ) , or work `` within the system '' . 
  ie , change the way they work so they look good within whatever assessment system you 're using . 
  the rebuttal i typically use when someone pulls out an example of a very big , popular site as not having valid html/css is this :, 
  google ( or whoever ) do this * not * because they 're lazy , but because there are a few very minor optimisations they can perform if they 're not limited to valid code . 
  they can afford the time and money necessary to test their site in every single version of every single browser in use today , because those minor optimisations are worth the trouble given the sheer size of their user base . 
  you , on the other hand have neither the userbase for those minor optimisations to make any measurable difference , nor the resources to test in hundreds of browser versions . 
  validating your code means you can be reasonably sure it 'll work everywhere , even if you only test in the most common browsers . 
  so fucking do it .
